# -*- coding: utf-8 -*-
"""Homework_4_Generators.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aA8lgpKjKdDsL9mR5DA1Xda_aDtABP68

Before you turn this problem in, make sure everything runs as expected. First, **restart the kernel** (in the menubar, select Kernel$\rightarrow$Restart) and then **run all cells** (in the menubar, select Cell$\rightarrow$Run All).

Make sure you fill in any place that says `YOUR CODE HERE` or "YOUR ANSWER HERE", as well as your name and collaborators below:
"""

NAME = "Yash Sharma"
COLLABORATORS = ""

"""---

# Homework 4: Generators
## CSE 30 Winter 2021

## Luca de Alfaro
Copyright Luca de Alfaro, 2021.  CC-BY-NC License.

# Instructions

## The Format of a Python Notebook

*This* is a Python Notebook homework.  It consists of various types of cells: 

* Text: you can read them :-) 
* Code: you should run them, as they may set up the problems that you are asked to solve.
* **Solution:** These are cells where you should enter a solution.  You will see a marker in these cells that indicates where your work should be inserted.  

```
    # YOUR CODE HERE
```    

* Test: These cells contains some tests, and are worth some points.  You should run the cells as a way to debug your code, and to see if you understood the question, and whether the output of your code is produced in the correct format.  The notebook contains both the tests you see, and some secret ones that you cannot see.  This prevents you from using the simple trick of hard-coding the desired output.

## Running your notebook

**Running a cell.**
To run a cell of the notebook, either click on the icon to its top left, or press shift-ENTER (or shift-Return). 

**Disconnections.**
When you open a notebook, Google automatically connects a server to the web page, so that you can type code in your browser, and the code is run on that server.  If you are idle for more than a few minutes, Google keeps all you typed (none of your work is lost), but the server may be disconnected due to inactivity.  When the server is disconnected, it loses all memory of anything you have defined (functions, classes, variables, etc). 

If you do get disconnected, select Runtime > Run All (or Runtime > Run before) to ensure everything is defined as it should. 

### DO NOT

* **Do not add, delete, reorder, remove cells.**  This breaks the relationship between your work, and the grading system, making it impossible to grade your work.

### Debugging
To debug, you can add print statements to your code.  They should have no effect on the tests.  Just be careful that if you add too many of them inside loops and similar, you may cause for some of the tests we will do such an enormous amount of output that grading might timeout (and you may not get credit for an answer). 

### Asking for help
The tutors and TAs should have access to the notebook; otherwise, you can always share a link with them.  In this way, they can take a look at your work and help you with debugging and with any questions you might have.

## Submitting Your Notebook

To submit:
* **Check your work.** Before submitting, select Runtime > Restart and Run All, and check that you don't get any unexpected error. 
* **Download the notebook.** Click on File > Download .ipynb . **Do not download the .py file.**
* **Upload.** Upload the .ipynb file to **[this Google form](https://docs.google.com/forms/d/e/1FAIpQLSfdSR6C9vvw-vJ9jKGfq6RNf6EpZ6-mXR92VKHTfvEjsHv2eQ/viewform?usp=sf_link)**.

## Tools

Here are some tools to help testing the homework.
"""

# Let me define the function I use for testing.  Don't change this cell. 

def check_equal(x, y, msg=None):
    if x == y:
        if msg is None:
            print("Success")
        else:
            print(msg, ": Success")
    else:
        if msg is None:
            print("Error:")
        else:
            print("Error in", msg, ":")
        print("    Your answer was:", x)
        print("    Correct answer: ", y)
    assert x == y, "%r and %r are different" % (x, y)

def subsets_set(subs_iterator):
    """Given an iterator subs_iterator that iterates over subsets, returns the
    set of the frozensets yielded by the iterator.  We use frozensets as 
    frozensets can be put in a set."""
    subsets = set()
    for s in subs_iterator:
        subsets.add(frozenset(s))
    return subsets

# Here is an example of how the above is used. 

def subsets():
    yield {3}
    yield {4, 5}
    yield {4, 6}
    
subsets_set(subsets())

"""## Question 1: An iterator that yields all prime numbers

Here's an iterator that produces all numbers that are not divisible by 2, 3, or 5:
"""

def not_div_235():
    i = 0
    while True:
        if (i % 2) * (i % 3) * (i % 5) > 0:
            yield i
        i += 1
        
for n in not_div_235():
    print(n)
    if n > 20:
        break

"""For Question 1, build an iterator that returns all the prime numbers.  The idea is to loop over all positive integers, test each one to see if it is prime, and if it is, `yield` it. """

### Question 1: implement a prime number generator

# My solution is simple and not particularly optimized, 
# and it is 12 lines long.

def prime_number_generator():
    """This generator returns all prime numbers."""
    n = 2
    while n > 1:
      x = True      
      for i in range(2, n):
          if (n % i) == 0:
              x = False
              break
      if x == True:
          yield n
      n += 1

i = 0
for n in prime_number_generator():
    print(n)
    i += 1
    if i == 10:
        break

# This is a place where you can write additional tests to help you test 
# your code, or debugging code, if you need.  You can also leave it blank. 

### YOUR CODE HERE

### 10 points: Tests for `prime_number_generator`

for n in prime_number_generator():
    if n == 33:
        raise Exception()
    elif n == 37:
        break

# HW 4

def subsets(s):
    if len(s) == 0:
        yield set()
    else:
        t = set(s)
        x = t.pop()
        for ss in subsets(t):
            yield ss
            yield ss | {x}

subsets({3,4,5})

for x in subsets({3, 4, 5}):
  print(x)

subsets_total({3, 4, 5}, total):

    ...
    3
    {4, 5}
    r = subsets_total({4, 5}, some_total)
    put together r and 3
    yield something.

def subsets(s):
    """Yields all subsets of a given set s."""
    if len(s) == 0:
        yield set()
    else:
        t = set(s)
        x = t.pop()
        for q in subsets(t):
            yield q
            yield q | {x}

for t in subsets({1,2,3}):
      print(t)

"""## Question 2: Iterating over all subsets with a given sum

Here is an iterator that yields all the subsets of a given set:
"""

def subsets(s):
    """Given a set s, yield all the subsets of s,
    including s itself and the empty set."""
    if len(s) == 0:
        yield set()
    else:
        ss = set(s)
        x = ss.pop()
        for t in subsets(ss):
            yield t
            yield t | {x}

"""Your goal is to write an iterator that iterates over all the subsets with a given sum. 
In detail, you should write a function `constant_sum_subsets(values, total)`, that takes as input: 

* a set `values` of non-negative numbers; 
* a non-negative number `total`, 

and returns an iterator that yields all subsets of `values` that sum to `total`. 

For instance, if `values` is $\{1, 2, 3\}$ and `total` is 3, then `constant_sum_subsets(values, total)` yields $\{1, 2\}$, and $\{3\}$, because those are the subsets of $\{1, 2, 3\}$ whose elements sum to 3. 

**Note:** A quick and dirty way of doing this is to use either [itertools](https://docs.python.org/3/library/itertools.html#itertools.combinations) or the `subset` function above to get an iterator over all subsets of `values`, and then filter only those which sum to `total`.  Don't do this.  Your code will be incredibly inefficient if only few subsets sum to `total`, and will in particular fail a test case.  Rather, try to encode the requirement of what subsets need to sum to into the recursion. 
"""

def constant_sum_subsets(values, total):

    if total == 0:
        yield set()
    if total < 0:
        pass
    if len(values) == 0:
        pass 
    else:
        ss = set(values)
        x = ss.pop()
        if (total - x) > 0: 
            for subs in constant_sum_subsets(ss, total - x):
                yield subs | {x}
        if (total - x) == 0:
            yield {x}
        for subs in constant_sum_subsets(ss, total):
            yield subs

# This is a place where you can write additional tests to help you test 
# your code, or debugging code, if you need.  You can also leave it blank.

for seq in constant_sum_subsets({1, 2, 3}, 3):
    print(seq)

for seq in constant_sum_subsets({1, 2, 3, 4, 5, 6, 7, 8}, 8):
    print(seq)

### Simple tests. 10 points. 

subs1 = constant_sum_subsets({1, 2, 3}, 3)
subs2 = {(1, 2), (3,)} # To represent {{1, 2}, {3}}
check_equal(subsets_set(subs1), subsets_set(subs2))

subs1 = constant_sum_subsets({1, 2, 3, 4}, 4)
subs2 = {(1, 3), (4,)} # To represent {{1, 3}, {4}}
check_equal(subsets_set(subs1), subsets_set(subs2))

subs1 = constant_sum_subsets({1, 2, 3, 4, 5}, 6)
subs2 = {(1, 2, 3), (1, 5), (2, 4)} # To represent {{1, 2, 3}, {1, 5}, {2, 4}}
check_equal(subsets_set(subs1), subsets_set(subs2))

### Advanced test. 10 points. 

# This test fails if you are not smart about using the fact that values are all non-negatives. 
values = set(range(10000, 10100))
num = 0
for _ in constant_sum_subsets(values, 2000):
    num += 1
check_equal(num, 0)

values = set(range(10000, 10100))
num = 0
for _ in constant_sum_subsets(values, 20020):
    num += 1
check_equal(num, 10)

### Final tests, hidden. 10 points. 
# This compares your solution with a known good solution.

pass