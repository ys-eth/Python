# -*- coding: utf-8 -*-
"""Homework_15_The_Holy_Queens.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f2VaivivseQB__d3jH7J5LgW1Q-z8Yp_

Before you turn this problem in, make sure everything runs as expected. First, **restart the kernel** (in the menubar, select Kernel$\rightarrow$Restart) and then **run all cells** (in the menubar, select Cell$\rightarrow$Run All).

Make sure you fill in any place that says `YOUR CODE HERE` or "YOUR ANSWER HERE", as well as your name and collaborators below:
"""

NAME = "Yash Sharma"
COLLABORATORS = ""

"""---

# Homework 15: The Holy Queens Problem
Luca de Alfaro, 2021

## About This Homework

The homework consists of 1 question, for a total of 45                            points.  The question has to parts: writing cell propagation, and writing the search for a solution. 

The instructions for working on homework assignments are available on Canvas; as a summary:

* Write your code only where indicated via 

        # YOUR CODE HERE
        
    If you write code in other places, it will be discarded during grading.
* Do not add/remove cells.
* The tests are implemented with assert statements: if they fail, you will see an error (a Python exception). If you see no error, you can assume that they pass.

Once you are done working on it, you can download the .ipynb and [submit to this Google Form](https://docs.google.com/forms/d/e/1FAIpQLSeFauR6c56720i21WNelqzhYqwyvx6s0FvhoeSCHvN9yj_S3A/viewform?usp=sf_link).

A chess queen can strike along the row, column, and the two diagonals.   The classical $n$-queens problem consists in placing $n$ queens on the chess board, so that no queen can eat another queen. 

We will study here the _holy_ queen problem: the chessboard can have _holes_, and in fact, can have an arbitrary shape.  The ability of a queen to move and attack is limited by the holes, and in general by the borders of the board: a queen cannot "jump" across a hole.  Your goal is to check whether you can place $n$ queens on a given board, which may contain holes.

## The board

For a board, we will use a Numpy representation as a matrix, with the following conventions for the content of each square: 

* 0: the cell is available for a queen. 
* 1: a queen is in the cell.
* 2: the cell is under attack from some queen (and thus not available). 
* 3: the cell contains a wall/hole, and a queen cannot traverse it.  

We provide for you here a function `show_board` that visualizes a board, using a `Q` for a queen, a dot for an empty location, a `#` for a hole or wall, and a `*` for a cell under attack.
"""

QUEEN = 1
EMPTY = 0
FORBIDDEN = 2
WALL = 3

def show_board(board):
    rows, cols = board.shape
    for r in range(rows):
        s = ""
        for c in range(cols):
            if board[r, c] == QUEEN:
                s += "Q"
            elif board[r, c] == FORBIDDEN:
                s += "*"
            elif board[r, c] == WALL:
                s += "#"
            elif board[r, c] == EMPTY:
                s += "."
            else:
                s += "?"
        print(s)

import numpy as np

board=np.array([
                [0, 0, 0, 0, 0, 0],
                [0, 1, 0, 3, 3, 0],
                [0, 0, 0, 3, 3, 0],
                [0, 0, 1, 0, 0, 0],
                [0, 0, 0, 0, 0, 0]
])
show_board(board)

"""Let us also write the opposite function `read_board`. """

def read_board(string_list):
    rows = len(string_list)
    cols = len(string_list[0])
    board = np.zeros((rows, cols))
    for r, row in enumerate(string_list):
        assert len(row) == cols
        for c, s in enumerate(row):
            if s == "Q":
                board[r, c] = QUEEN
            elif s == "#":
                board[r, c] = WALL
            elif s == "*":
                board[r, c] = FORBIDDEN
    return board

bs = [
    "......", 
    ".Q.##.",
    "...##.",
    "..Q...",
    "......"
    ]
show_board(read_board(bs))

"""## Question 1

Here is the class `HolyQueens`.  You must define two methods: 

The method `propagate` propagates the constraints, marking with `FORBIDDEN` all the locations that can be reached by the queens on the board. 

The method `search` searches for a solution with a given number of queens.  If a solution is found, it returns the board.  If no solution is found, it returns `None`.  The method `search` should implement the propagate-guess-recur framework: if not enough queens are present on the board, it first propagates the constraints from the current queens if any, then it guesses the position for a new queen, and then it recurs, looking for a solution in which one fewer queen needs to be placed. 

We advise you to implement `propagate` first, and then `search`. 
"""

class HolyQueens(object):
    
    def __init__(self, board):
        self.board = board
        self.num_rows, self.num_cols = self.board.shape
        # Current number of queens in the board. 
        self.num_queens = np.sum(self.board == QUEEN)

    def show(self):
        show_board(self.board)

    def propagate(self):
        """Propagates the information on the board, marking with 2 the 
        positions where a queen cannot be."""
        # The solution can be written concisely in about 20 lines of code, 
        # but if you brute force it, it might be quite long. 
        r = list(np.argwhere(self.board == QUEEN))
        d = [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, 1), (1, 1), (1, -1), (-1, -1)]
        for i in r:
            for n in d:
                fut_y = i[0] + n[0]
                fut_x = i[1] + n[1]
                while 0 <= fut_y < self.num_rows and 0 <= fut_x < self.num_cols and (self.board[fut_y][fut_x]) in [0, 2]:
                    self.board[fut_y][fut_x] = 2
                    fut_y, fut_x = fut_y + n[0], fut_x + n[1]
    
    def search(self, total_num_queens):
        """Searches for a solution, starting from the given board, 
        which contains exactly num_queens.  It returns the board, 
        if such a solution is found, or None, if none could be found
        after exhaustive search."""
        pass
        self.propagate()
        y_b = (self.num_queens)
        x_b = np.copy(self.board)
        sp = list(np.argwhere(self.board == EMPTY))
        if len(sp) < (total_num_queens - self.num_queens):
            return None
        elif (total_num_queens - self.num_queens) == 0:
            return self.board
        while len(sp) > 0:
            q = sp.pop()
            self.board[q[0]][q[1]] = 1
            self.num_queens += 1
            k = self.search(total_num_queens)
            if k is None:
                self.board = np.copy(x_b)
                self.num_queens = y_b
            elif k is not None:
                return self.board

## You can write tests here. 

### YOUR CODE HERE

"""Let us see how propagate works. """

## 5 points. Propagation. 

# Propagating this
bs = [
    "......", 
    ".Q.##.",
    "...##.",
    "..Q...",
    "......"
    ]
# should give this:
bs_prop = [
    "***...",
    "*Q*##.",
    "***##.",
    "**Q***",
    ".****."]

hq = HolyQueens(read_board(bs))
hq.propagate()
hq.show()
assert (hq.board == read_board(bs_prop)).all()

## 5 points. Propagation. 

# Propagating this
bs = [
    ".....Q", 
    "..Q##.",
    "...##.",
    ".#....",
    ".Q...."
    ]
# should give this:
bs_prop = [
    "*****Q",
    "**Q##*",
    ".**##*",
    "*#*..*",
    "*Q****"]

hq = HolyQueens(read_board(bs))
hq.propagate()
hq.show()
assert (hq.board == read_board(bs_prop)).all()

## Here you can write more tests.

## 5 points.  Hidden tests on propagation.

## 10 points: Hidden tests on propagation.

"""Let us check the search function now. """

## 5 points: tests for search function. 

bs = [
    "......", 
    "...##.",
    "...##.",
    "......",
    "......"
    ]
hq = HolyQueens(read_board(bs))
r = hq.search(4)
assert r is not None
# You should get a solution with 4 non-interfering queens. 
show_board(r)

## 5 points: tests for search function 

bs = [
    "......", 
    "...##.",
    "...##.",
    "......",
    "......"
    ]
hq = HolyQueens(read_board(bs))
r = hq.search(6)
assert r is not None
# You should get a solution with 6 non-interfering queens. 
show_board(r)

## 10 points: hidden tests for search function

